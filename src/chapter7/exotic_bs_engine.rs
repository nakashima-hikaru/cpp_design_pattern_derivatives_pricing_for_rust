use crate::chapter4::parameters::Parameters;
use crate::chapter6::random2::Random;
use crate::chapter7::exotic_engine::ExoticEngine;
use crate::chapter7::exotic_engine::ExoticEngineData;
use crate::chapter7::path_dependent::PathDependent;

pub struct ExoticBSEngine<'a, T: PathDependent, S: Parameters, R: Random> {
    exotic_engine_data: ExoticEngineData<'a, T, S>,
    /// A random number generator
    the_generator: &'a mut R,
    /// Drifts
    drifts: Vec<f64>,
    /// The standard deviations of logarithm of the stock price
    standard_deviations: Vec<f64>,
    /// A logarithm of a spot value
    log_spot: f64,
    /// times to record drifts, standard deviations and variates
    number_of_times: usize,
    /// Gaussian random variables generated by `self.the_generator`
    variates: Vec<f64>,
}

impl<'a, T: PathDependent, S: Parameters, R: Random> ExoticBSEngine<'a, T, S, R> {
    /// Constructor.
    ///
    /// # Arguments
    ///
    /// * `exotic_engine_data` - Common information on exotic engine
    /// * `d` - A dividend
    /// * `vol` - A volatility
    /// * `the_generator` - A random number generator
    /// * `spot` - A spot value of a stock
    pub fn new(
        the_product: &'a T,
        r: &'a S,
        d: impl Parameters,
        vol: impl Parameters,
        the_generator: &'a mut R,
        spot: f64,
    ) -> ExoticBSEngine<'a, T, S, R> {
        let exotic_engine_data = ExoticEngineData::new(the_product, r);
        let times = exotic_engine_data.get_the_product().get_look_at_times();
        let number_of_times = times.len();

        the_generator.reset_dimensionality(number_of_times);
        let mut drifts = vec![0.0; number_of_times];
        let mut standard_deviations = vec![0.0; number_of_times];

        let variance = vol.integral_square(0.0, times[0]);
        drifts[0] = exotic_engine_data.get_r().integral(0.0, times[0])
            - d.integral(0.0, times[0])
            - 0.5 * variance;
        standard_deviations[0] = variance.sqrt();
        for j in 1..number_of_times {
            let this_variance = vol.integral_square(times[j - 1], times[j]);
            drifts[j] = exotic_engine_data.get_r().integral(times[j - 1], times[j])
                - d.integral(times[j - 1], times[j])
                - 0.5 * this_variance;
            standard_deviations[j] = this_variance.sqrt();
        }
        let variates = vec![0.0; number_of_times];
        ExoticBSEngine {
            exotic_engine_data,
            the_generator,
            drifts,
            standard_deviations,
            log_spot: spot.ln(),
            number_of_times,
            variates,
        }
    }
}

impl<'a, T: PathDependent, S: Parameters, R: Random> ExoticEngine<T, S>
    for ExoticBSEngine<'a, T, S, R>
{
    /// Returns the pointer of `self.exotic_engine_data`
    fn get_exotic_engine_data(&self) -> &ExoticEngineData<T, S> {
        &self.exotic_engine_data
    }

    /// Stores spot values on a path.
    ///
    /// # Arguments
    ///
    /// * `spot_values` - A container to store spot values
    fn get_one_path(&mut self, spot_values: &mut [f64]) {
        self.the_generator.get_gaussians(&mut self.variates);
        let mut current_log_spot = self.log_spot;
        for (j, spot_value) in spot_values
            .iter_mut()
            .enumerate()
            .take(self.number_of_times)
        {
            current_log_spot += self.drifts[j] + self.standard_deviations[j] * self.variates[j];
            *spot_value = current_log_spot.exp();
        }
    }
}
