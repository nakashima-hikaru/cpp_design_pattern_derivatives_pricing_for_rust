use crate::chapter4::parameters::Parameters;
use crate::chapter6::random2::Random;
use crate::chapter7::exotic_engine::ExoticEngine;
use crate::chapter7::path_dependent::PathDependent;

pub struct ExoticBSEngine<'a, R: Random> {
    /// A random number generator
    the_generator: &'a mut R,
    /// Drifts
    drifts: Vec<f64>,
    /// The standard deviations of logarithm of the stock price
    standard_deviations: Vec<f64>,
    /// A logarithm of a spot value
    log_spot: f64,
    /// times to record drifts, standard deviations and variates
    number_of_times: usize,
    /// Gaussian random variables generated by `self.the_generator`
    variates: Vec<f64>,
}

impl<'a, R: Random> ExoticBSEngine<'a, R> {
    /// Constructor.
    ///
    /// # Arguments
    ///
    /// * `exotic_engine_data` - Common information on exotic engine
    /// * `d` - A dividend
    /// * `vol` - A volatility
    /// * `the_generator` - A random number generator
    /// * `spot` - A spot value of a stock
    pub fn new(
        look_at_times: &Vec<f64>,
        r: &impl Parameters,
        d: impl Parameters,
        vol: impl Parameters,
        the_generator: &'a mut R,
        spot: f64,
    ) -> ExoticBSEngine<'a, R> {
        let number_of_times = look_at_times.len();

        the_generator.reset_dimensionality(number_of_times);
        let mut drifts = vec![0.0; number_of_times];
        let mut standard_deviations = vec![0.0; number_of_times];

        let variance = vol.integral_square(0.0, look_at_times[0]);
        drifts[0] =
            r.integral(0.0, look_at_times[0]) - d.integral(0.0, look_at_times[0]) - 0.5 * variance;
        standard_deviations[0] = variance.sqrt();
        for j in 1..number_of_times {
            let this_variance = vol.integral_square(look_at_times[j - 1], look_at_times[j]);
            drifts[j] = r.integral(look_at_times[j - 1], look_at_times[j])
                - d.integral(look_at_times[j - 1], look_at_times[j])
                - 0.5 * this_variance;
            standard_deviations[j] = this_variance.sqrt();
        }
        let variates = vec![0.0; number_of_times];
        ExoticBSEngine {
            the_generator,
            drifts,
            standard_deviations,
            log_spot: spot.ln(),
            number_of_times,
            variates,
        }
    }
}

impl<'a, T: PathDependent, S: Parameters, R: Random> ExoticEngine<T, S> for ExoticBSEngine<'a, R> {
    /// Stores spot values on a path.
    ///
    /// # Arguments
    ///
    /// * `spot_values` - A container to store spot values
    fn get_one_path(&mut self, spot_values: &mut [f64]) {
        self.the_generator.get_gaussians(&mut self.variates);
        let mut current_log_spot = self.log_spot;
        for (j, spot_value) in spot_values
            .iter_mut()
            .enumerate()
            .take(self.number_of_times)
        {
            current_log_spot += self.drifts[j] + self.standard_deviations[j] * self.variates[j];
            *spot_value = current_log_spot.exp();
        }
    }
}
